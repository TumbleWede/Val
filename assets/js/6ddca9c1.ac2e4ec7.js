"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[300],{336:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>h,frontMatter:()=>o,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"scopes","title":"Scopes","description":"In Val, scopes are Val objects with no value with the intention of storing other values.","source":"@site/docs/scopes.md","sourceDirName":".","slug":"/scopes","permalink":"/Val/docs/scopes","draft":false,"unlisted":false,"editUrl":"https://github.com/TumbleWede/Val/edit/main/docs/scopes.md","tags":[],"version":"current","sidebarPosition":5,"frontMatter":{"sidebar_position":5},"sidebar":"defaultSidebar","previous":{"title":"Operator Methods","permalink":"/Val/docs/operations"},"next":{"title":"Destroying States","permalink":"/Val/docs/destroy"}}');var r=t(4848),i=t(8453);const o={sidebar_position:5},a="Scopes",l={},c=[];function d(e){const n={admonition:"admonition",code:"code",h1:"h1",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,i.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"scopes",children:"Scopes"})}),"\n",(0,r.jsx)(n.h1,{id:"intro",children:"Intro"}),"\n",(0,r.jsx)(n.p,{children:"In Val, scopes are Val objects with no value with the intention of storing other values."}),"\n",(0,r.jsxs)(n.p,{children:["Before we dive into using ",(0,r.jsx)(n.code,{children:"Val.scope"}),", let's first create a Val with fields:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-lua",children:"local rect = Val.new({\r\n\tsize = Val.new(Vector2.new(5, 3)),\r\n\tpos = Val.new(Vector2.new(6, 12))\r\n})\n"})}),"\n",(0,r.jsxs)(n.p,{children:["In this example, we created a state with fields ",(0,r.jsx)(n.code,{children:"size"})," and ",(0,r.jsx)(n.code,{children:"pos"}),". However, we must call ",(0,r.jsx)(n.code,{children:"Val:get"})," to access these fields (e.g. ",(0,r.jsx)(n.code,{children:"rect:get().size"}),")."]}),"\n",(0,r.jsx)(n.p,{children:"We can skip this step by adding the fields directly inside the state object rather than inside the state's value:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-lua",children:"local rect = Val.none() -- alias for Val.new(nil)\r\nrect.size = Val.new(Vector2.new(5, 3))\r\nrect.pos = Val.new(Vector2.new(6, 12))\n"})}),"\n",(0,r.jsxs)(n.p,{children:["This time, we can directly access ",(0,r.jsx)(n.code,{children:"size"})," and ",(0,r.jsx)(n.code,{children:"pos"})," (e.g. ",(0,r.jsx)(n.code,{children:"rect.size"}),") without the need of ",(0,r.jsx)(n.code,{children:"rect:get()"}),". Val does not stop you from modifying or accessing keys inside any states (unless the state is dead), so we can get away with this safely as long as we don't override any internal/private fields."]}),"\n",(0,r.jsx)(n.admonition,{type:"warning",children:(0,r.jsxs)(n.p,{children:["Avoid adding custom fields with the following names: ",(0,r.jsx)(n.code,{children:"_value"}),", ",(0,r.jsx)(n.code,{children:"_listeners"}),", ",(0,r.jsx)(n.code,{children:"_dependents"}),", ",(0,r.jsx)(n.code,{children:"_disconnects"}),", ",(0,r.jsx)(n.code,{children:"_eval"}),", and ",(0,r.jsx)(n.code,{children:"set"})]})}),"\n",(0,r.jsxs)(n.h1,{id:"using-valscope",children:["Using ",(0,r.jsx)(n.code,{children:"Val.scope"})]}),"\n",(0,r.jsxs)(n.p,{children:["Now let's do the same thing using ",(0,r.jsx)(n.code,{children:"Val.scope"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-lua",children:"local rect = Val.scope {\r\n\tsize = Val.new(Vector2.new(5, 3)),\r\n\tpos = Val.new(Vector2.new(6, 12))\r\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["This code example will give us the same result as the previous example: a valueless state with custom fields. The benefit of using ",(0,r.jsx)(n.code,{children:"Val.scope"})," instead of ",(0,r.jsx)(n.code,{children:"Val.none()"})," is that you can store your custom fields in a table argument."]}),"\n",(0,r.jsxs)(n.p,{children:["For dictionaries, using ",(0,r.jsx)(n.code,{children:"Val.scope"})," or ",(0,r.jsx)(n.code,{children:"Val.none()"})," is based on your preference, but you will absolutely need to use ",(0,r.jsx)(n.code,{children:"Val.scope"})," for arrays:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-lua",children:"local nums = Val.scope {\r\n\tVal.new(1),\r\n\tVal.new(2),\r\n\tVal.new(3),\r\n\tVal.new(4)\r\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["In this example, the list of states will be directly inside ",(0,r.jsx)(n.code,{children:"nums"})," rather than inside its value."]}),"\n",(0,r.jsx)(n.h1,{id:"iteration",children:"Iteration"}),"\n",(0,r.jsx)(n.p,{children:"You can safely iterate through a scope's keys without iterating through the state's private fields:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-lua",children:"local t = Val.scope {\r\n\ta = Val.new(1),\r\n\tb = Val.new(2),\r\n\tc = Val.new(3)\r\n}\r\n\r\nfor i, v in t do\r\n\tprint(i, v:get())\r\nend\r\n-- a 1\r\n-- b 2\r\n-- c 3\n"})}),"\n",(0,r.jsx)(n.p,{children:"Because we used generic iteration, the for loop utilized the scope's iteration metamethod which will ensure that private keys will not be iterated through."}),"\n",(0,r.jsx)(n.p,{children:"Now let's do the same thing for an array:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-lua",children:"local t = Val.scope {\r\n\tVal.new(7),\r\n\tVal.new(8),\r\n\tVal.new(9)\r\n}\r\n\r\nfor i, v in ipairs(t) do\r\n\tprint(i, v:get())\r\nend\r\n-- 1 7\r\n-- 2 8\r\n-- 3 9\n"})}),"\n",(0,r.jsxs)(n.p,{children:["In this example, we used ",(0,r.jsx)(n.code,{children:"ipairs"})," instead of generic iteration to iterate through the indices. Although generic iteration could have produced the exact same result, ",(0,r.jsx)(n.code,{children:"ipairs"})," is faster."]}),"\n",(0,r.jsx)(n.admonition,{type:"tip",children:(0,r.jsxs)(n.p,{children:["Always use ",(0,r.jsx)(n.code,{children:"ipairs"})," over generic iteration if you only need to use the index-value pairs and not key-value pairs."]})}),"\n",(0,r.jsx)(n.admonition,{type:"danger",children:(0,r.jsxs)(n.p,{children:["Using ",(0,r.jsx)(n.code,{children:"pairs"})," will iterate through the state's private keys, which can lead to undefined behavior. Always use either ",(0,r.jsx)(n.code,{children:"ipairs"})," or generic iteration for scopes."]})}),"\n",(0,r.jsx)(n.p,{children:"Now let's do an example of combining numeric and string keys in the scope. In this case, there is a significant difference in each iteration method:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-lua",children:"local t = Val.scope {\r\n\ta = Val.new(1),\r\n\tb = Val.new(2),\r\n\tc = Val.new(3),\r\n\tVal.new(7),\r\n\tVal.new(8),\r\n\tVal.new(9)\r\n}\r\n\r\n-- generic iteration\r\nfor i, v in t do\r\n\tprint(i, v:get())\r\nend\r\n-- 1 7\r\n-- 2 8\r\n-- 3 9\r\n-- a 1\r\n-- b 2\r\n-- c 3\r\n\r\n-- ipairs\r\nfor i, v in ipairs(t) do\r\n\tprint(i, v:get())\r\nend\r\n-- 1 7\r\n-- 2 8\r\n-- 3 9\r\n\r\n-- pairs (why you should avoid this)\r\nfor i, v in pairs(t) do\r\n\tprint(i, v:get())\r\nend\r\n-- 1 7\r\n-- 2 8\r\n-- 3 9\r\n-- a 1\r\n-- error: attempt to call missing method 'get' of table\n"})}),"\n",(0,r.jsx)(n.p,{children:"In this example, all three iterator methods produced a different result:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Generic iteration printed every custom key-value/index-value pair"}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"ipairs"})," only printed every index-value pair"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"pairs"})," resulted in an error after the for loop tried to access a private key and assumed it was a state"]}),"\n"]}),"\n",(0,r.jsx)(n.h1,{id:"observer-behavior-with-scopes",children:"Observer Behavior with Scopes"}),"\n",(0,r.jsx)(n.admonition,{type:"note",children:(0,r.jsx)(n.p,{children:"Val currently does not have special observer behavior for scopes, but this is subject to change in the future if it becomes a significant limitation."})}),"\n",(0,r.jsxs)(n.p,{children:["Observers do not work directly on scopes because they listen to the value of the scope, which is typically just ",(0,r.jsx)(n.code,{children:"nil"}),".\r\nHowever, you can simply overcome this by adding observers to the fields and not the scope:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-lua",children:'local rect = Val.scope {\r\n\tpos = Val.new(Vector2.new(2, 6)),\r\n\tsize = Val.new(Vector2.new(4, 3))\r\n}\r\n\r\nlocal onChange = function()\r\n\tprint("Rectangle of size", rect.size:get(), "located at", rect.pos:get())\r\nend\r\nrect.pos:on(onChange)\r\nrect.size:on(onChange, true) -- Rectangle of size 4, 3 located at 2, 6\r\nrect.pos:set(Vector2.new(5, 10)) -- Rectangle of size 4, 3 located at 5, 10\r\nrect.size:set(Vector2.new(1, 2)) -- Rectangle of size 1, 2 located at 5, 10\n'})}),"\n",(0,r.jsx)(n.p,{children:"When working with an unknown list of index-value pairs, we can use a table to keep track of observers for each index:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-lua",children:'local list = Val.scope {\r\n\tVal.new(1),\r\n\tVal.new(2),\r\n\tVal.new(3)\r\n}\r\n\r\nlocal onChange = function()\r\n\tlocal sum = 0\r\n\tfor i, v in ipairs(list) do\r\n\t\tsum += v:get()\r\n\tend\r\n\tprint("The sum of the values of the list is", sum)\r\nend\r\n\r\nlocal observers = {}\r\nfor i, v in ipairs(list) do\r\n\tobservers[i] = v:on(onChange)\r\nend\r\nlist[1]:set(list[1]:get(), true) -- Force update the value to immediately call the observer once\r\n-- The sum of the values of the list is 6\r\nlist[2]:set(10) -- The sum of the values of the list is 14\r\n\r\n-- Destroy scope\r\nfor i, v in ipairs(observers) do\r\n\tv()\r\nend\r\nobservers = nil -- Also dereferences the disconnects\r\nlist:die() -- Also destroys the three values\n'})}),"\n",(0,r.jsx)(n.admonition,{type:"tip",children:(0,r.jsx)(n.p,{children:"Remember that you only need to use Val when you care about observing/reacting to value changes. If you have a field that you don't need to actively listen to, it does not need to be a Val object. You also only really need to use a scope rather than a regular table if/when you plan on destroying all the internal states at once for memory management purposes."})})]})}function h(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>o,x:()=>a});var s=t(6540);const r={},i=s.createContext(r);function o(e){const n=s.useContext(i);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:o(e.components),s.createElement(i.Provider,{value:n},e.children)}}}]);