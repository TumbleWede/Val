"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[744],{5966:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>l,default:()=>h,frontMatter:()=>r,metadata:()=>s,toc:()=>i});const s=JSON.parse('{"id":"computeds","title":"Computeds","description":"This library supports computed states, which are essentially states whose values are derived from dependent states. When a dependent state changes, the computed state will automatically update along with it. This means that you cannot change the value of a computed state manually.","source":"@site/docs/computeds.md","sourceDirName":".","slug":"/computeds","permalink":"/Val/docs/computeds","draft":false,"unlisted":false,"editUrl":"https://github.com/TumbleWede/Val/edit/main/docs/computeds.md","tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"sidebar_position":3},"sidebar":"defaultSidebar","previous":{"title":"Observers","permalink":"/Val/docs/observers"},"next":{"title":"Operator Methods","permalink":"/Val/docs/operations"}}');var a=n(4848),o=n(8453);const r={sidebar_position:3},l="Computeds",c={},i=[];function d(e){const t={admonition:"admonition",code:"code",h1:"h1",header:"header",p:"p",pre:"pre",...(0,o.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(t.header,{children:(0,a.jsx)(t.h1,{id:"computeds",children:"Computeds"})}),"\n",(0,a.jsx)(t.h1,{id:"usage",children:"Usage"}),"\n",(0,a.jsx)(t.p,{children:"This library supports computed states, which are essentially states whose values are derived from dependent states. When a dependent state changes, the computed state will automatically update along with it. This means that you cannot change the value of a computed state manually."}),"\n",(0,a.jsx)(t.p,{children:"Let's look at a basic example:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-lua",children:"local a = Val.new(3)\r\nlocal b = Val.new(4)\r\nlocal h = Val.calc(function(get)\r\n\treturn math.sqrt(get(a)^2 + get(b)^2)\r\nend)\r\n\r\nprint(h:get()) -- 5\r\na:set(6)\r\nb:set(8)\r\nprint(h:get()) -- 10\n"})}),"\n",(0,a.jsxs)(t.p,{children:["In this example, we created a computed that calculates the hypotenuse, ",(0,a.jsx)(t.code,{children:"h"}),", of a right triangle based on the side lengths, ",(0,a.jsx)(t.code,{children:"a"})," and ",(0,a.jsx)(t.code,{children:"b"}),"."]}),"\n",(0,a.jsxs)(t.p,{children:["We used the ",(0,a.jsx)(t.code,{children:"Val.calc"})," constructor to create the computed, which we passed in a callback function as the argument. This function will return the value of the computed based on the values of the other states we want to use (",(0,a.jsx)(t.code,{children:"a"})," and ",(0,a.jsx)(t.code,{children:"b"})," in this case). When ",(0,a.jsx)(t.code,{children:"a"})," or ",(0,a.jsx)(t.code,{children:"b"})," updates its value, the callback will be called, thus allowing it to update its value."]}),"\n",(0,a.jsxs)(t.p,{children:["Notice how the callback takes in a function called ",(0,a.jsx)(t.code,{children:"get"})," that we use instead of the ",(0,a.jsx)(t.code,{children:"Val:get()"})," method. This special ",(0,a.jsx)(t.code,{children:"get"})," function tells the computed which values it depends on, so if we just used ",(0,a.jsx)(t.code,{children:"a:get()"})," instead of ",(0,a.jsx)(t.code,{children:"get(a)"}),", then ",(0,a.jsx)(t.code,{children:"h"})," would not update if the value of ",(0,a.jsx)(t.code,{children:"a"})," were to change."]}),"\n",(0,a.jsx)(t.admonition,{type:"note",children:(0,a.jsxs)(t.p,{children:["You can call ",(0,a.jsx)(t.code,{children:"get(Val<T>)"})," on the same state multiple times safely; the resulting computed will refer to the value only once, even if you multi-call ",(0,a.jsx)(t.code,{children:"get(Val<T>)"}),"."]})}),"\n",(0,a.jsx)(t.p,{children:"Let's look at another triangle example below:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-lua",children:"local a, b, c = Val.new(3), Val.new(4), Val.new(5)\r\nlocal s = Val.calc(function(get)\r\n\treturn (get(a) + get(b) + get(c)) / 2\r\nend)\r\n-- A = sqrt(s * (s-a) * (s-b) * (s-c)), where s = (a+b+c) / 2\r\nlocal area = Val.calc(function(get)\r\n\tlocal s2 = get(s)\r\n\treturn math.sqrt(s2 * (s2 - get(a)) * (s2 - get(b)) * (s2 - get(c)))\r\nend)\r\n\r\nprint(area:get()) -- 6\r\na:set(6)\r\nb:set(8)\r\nc:set(10)\r\nprint(area:get()) -- 24\n"})}),"\n",(0,a.jsxs)(t.p,{children:["This example represents Heron's Formula, which calculates the area of a triangle given only its three side lengths. However, this formula needs a variable, ",(0,a.jsx)(t.code,{children:"s"}),", which is equal to half of the sum of the three side lengths. Luckily, we can accomplish this using a computed, so we never have to worry about updating ",(0,a.jsx)(t.code,{children:"s"})," when we need to update one of the side lengths."]}),"\n",(0,a.jsxs)(t.p,{children:["Computed states are still considered states, which means that we can also use them in other computeds. In this example, we used the computed ",(0,a.jsx)(t.code,{children:"s"})," inside the computed ",(0,a.jsx)(t.code,{children:"area"}),". This means that when a side length changes, ",(0,a.jsx)(t.code,{children:"s"})," will update which will also update ",(0,a.jsx)(t.code,{children:"area"}),"."]}),"\n",(0,a.jsx)(t.admonition,{type:"note",children:(0,a.jsxs)(t.p,{children:["Although chaining computeds like this is possible, there is one drawback, where the final computed may fire multiple times rather than once. In this case, if we set the value of a side length, ",(0,a.jsx)(t.code,{children:"s"})," will update, but since ",(0,a.jsx)(t.code,{children:"area"})," depends on both the side lengths AND ",(0,a.jsx)(t.code,{children:"s"}),", this means that ",(0,a.jsx)(t.code,{children:"area"})," will update twice instead of once. For small calculations like in this example, it's not really a problem, but if you were to have expensive computeds, it would be better to avoid this practice."]})}),"\n",(0,a.jsx)(t.h1,{id:"observer-behavior-with-computeds",children:"Observer Behavior with Computeds"}),"\n",(0,a.jsx)(t.p,{children:"Observers for computeds behave the exact same as observers for states:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-lua",children:'local s = Val.new(10)\r\nlocal area = Val.calc(function(get)\r\n\treturn get(s) ^ 2\r\nend)\r\n\r\ns:on(function(new)\r\n\tprint("Side length set to", new)\r\nend)\r\narea:on(function(new)\r\n\tprint("Area updated to", new)\r\nend)\r\n\r\ns:set(20)\r\n-- Side length set to 20\r\n-- Area updated to 400\n'})})]})}function h(e={}){const{wrapper:t}={...(0,o.R)(),...e.components};return t?(0,a.jsx)(t,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}},8453:(e,t,n)=>{n.d(t,{R:()=>r,x:()=>l});var s=n(6540);const a={},o=s.createContext(a);function r(e){const t=s.useContext(o);return s.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function l(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:r(e.components),s.createElement(o.Provider,{value:t},e.children)}}}]);