"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[790],{5543:e=>{e.exports=JSON.parse('{"functions":[{"name":"new","desc":"Constructs a new state\\n```lua\\nlocal num = Val.new(20)\\nlocal str = Val.new(\\"Hello, World!\\")\\nlocal bool = Val.new(true)\\n```","params":[{"name":"value","desc":"","lua_type":"T"}],"returns":[{"desc":"","lua_type":"Val<T>\\r\\n"}],"function_type":"static","source":{"line":54,"path":"src/init.luau"}},{"name":"set","desc":"Sets the value of the state\\n```lua\\nlocal num = Val.new(10)\\nnum:set(20)\\nlocal str = Val.new(\\"Foo\\")\\nstr:set(\\"Bar\\")\\n```","params":[{"name":"value","desc":"the new value of the state","lua_type":"T"},{"name":"forceSet","desc":"forces the method to execute anyway in case the old value is the same as the new value","lua_type":"boolean?"}],"returns":[],"function_type":"method","source":{"line":75,"path":"src/init.luau"}},{"name":"get","desc":"```lua\\nlocal num = Val.new(10)\\nprint(num:get()) -- 10\\n```","params":[],"returns":[{"desc":"the value of the state","lua_type":"T"}],"function_type":"method","source":{"line":94,"path":"src/init.luau"}},{"name":"add","desc":"Increases state by `value`\\n\\nNote: Val does not check if the state\'s type supports this operation\\n```lua\\nlocal num = Val.new(5)\\nnum:add(2) -- 5+2 -> 7\\n```","params":[{"name":"value","desc":"","lua_type":"any"}],"returns":[{"desc":"","lua_type":"Val"}],"function_type":"method","source":{"line":111,"path":"src/init.luau"}},{"name":"sub","desc":"Decreases state by `value`\\n\\nNote: Val does not check if the state\'s type supports this operation\\n```lua\\nlocal num = Val.new(5)\\nnum:sub(2) -- 5-2 -> 3\\n```","params":[{"name":"value","desc":"","lua_type":"any"}],"returns":[{"desc":"","lua_type":"Val"}],"function_type":"method","source":{"line":129,"path":"src/init.luau"}},{"name":"mul","desc":"Multiplies state by `value`\\n\\nNote: Val does not check if the state\'s type supports this operation\\n```lua\\nlocal num = Val.new(5)\\nnum:mul(2) -- 5*2 -> 10\\n```","params":[{"name":"value","desc":"","lua_type":"any"}],"returns":[{"desc":"","lua_type":"Val"}],"function_type":"method","source":{"line":147,"path":"src/init.luau"}},{"name":"div","desc":"Divides state by `value`\\n\\nNote: Val does not check if the state\'s type supports this operation\\n```lua\\nlocal num = Val.new(5)\\nnum:div(2) -- 5/2 -> 2.5\\n```","params":[{"name":"value","desc":"","lua_type":"any"}],"returns":[{"desc":"","lua_type":"Val"}],"function_type":"method","source":{"line":165,"path":"src/init.luau"}},{"name":"idiv","desc":"Floor divides state by `value`\\n\\nNote: Val does not check if the state\'s type supports this operation\\n```lua\\nlocal num = Val.new(5)\\nnum:idiv(2) -- 2 remainder 1 -> 2\\n```","params":[{"name":"value","desc":"","lua_type":"any"}],"returns":[{"desc":"","lua_type":"Val"}],"function_type":"method","source":{"line":183,"path":"src/init.luau"}},{"name":"mod","desc":"Applies the modulus of state by `value`\\n\\nNote: Val does not check if the state\'s type supports this operation\\n```lua\\nlocal num = Val.new(5)\\nnum:mod(2) -- 2 remainder 1 -> 1\\n```","params":[{"name":"value","desc":"","lua_type":"any"}],"returns":[{"desc":"","lua_type":"Val"}],"function_type":"method","source":{"line":201,"path":"src/init.luau"}},{"name":"pow","desc":"Exponentiates state by `value`\\n\\nNote: Val does not check if the state\'s type supports this operation\\n```lua\\nlocal num = Val.new(5)\\nnum:pow(2) -- 5^2 -> 25\\n```","params":[{"name":"value","desc":"","lua_type":"any"}],"returns":[{"desc":"","lua_type":"Val"}],"function_type":"method","source":{"line":219,"path":"src/init.luau"}},{"name":"cat","desc":"Concatenates state by `value`\\n\\nNote: Val does not check if the state\'s type supports this operation\\n```lua\\nlocal str = Val.new(\\"Hello, \\")\\nstr:cat(\\"World!\\") -- \\"Hello, \\" .. \\"World!\\" -> \\"Hello, World!\\"\\n```","params":[{"name":"value","desc":"","lua_type":"any"}],"returns":[{"desc":"","lua_type":"Val"}],"function_type":"method","source":{"line":237,"path":"src/init.luau"}},{"name":"flip","desc":"Toggles the state\'s value (value = not value)\\n\\nUsing this method on a non-boolean state will convert it into a boolean state\\n\\nNote: Val does not check if the state\'s type supports this operation\\n```lua\\nlocal bool = Val.new(true)\\nbool:flip() -- false\\nbool:flip():flip():flip() -- true -> false -> true\\n```","params":[],"returns":[{"desc":"","lua_type":"Val"}],"function_type":"method","source":{"line":257,"path":"src/init.luau"}},{"name":"eq","desc":"Checks if the state\'s value is equal to the value of `other`\\n\\nEquivalent to state:get() == other:get()\\n```lua\\nlocal a = Val.new(10)\\nlocal b = Val.new(10)\\nlocal c = Val.new(20)\\nprint(a:eq(b)) -- true\\nprint(a:eq(c)) -- false\\n```","params":[{"name":"other","desc":"","lua_type":"Val"}],"returns":[{"desc":"","lua_type":"boolean"}],"function_type":"method","source":{"line":278,"path":"src/init.luau"}},{"name":"lt","desc":"Checks if the state\'s value is less than the value of `other`\\n\\nEquivalent to state:get() < other:get()\\n```lua\\nlocal a = Val.new(20)\\nlocal b = Val.new(30)\\nlocal c = Val.new(10)\\nlocal d = Val.new(20)\\nprint(a:lt(b)) -- true\\nprint(a:lt(c)) -- false\\nprint(a:lt(d)) -- false\\n```","params":[{"name":"other","desc":"","lua_type":"Val"}],"returns":[{"desc":"","lua_type":"boolean"}],"function_type":"method","source":{"line":300,"path":"src/init.luau"}},{"name":"le","desc":"Checks if the state\'s value is less than or equal to the value of `other`\\n\\nEquivalent to state:get() < other:get()\\n```lua\\nlocal a = Val.new(20)\\nlocal b = Val.new(30)\\nlocal c = Val.new(10)\\nlocal d = Val.new(20)\\nprint(a:le(b)) -- true\\nprint(a:le(c)) -- false\\nprint(a:le(d)) -- true\\n```","params":[{"name":"other","desc":"","lua_type":"Val"}],"returns":[{"desc":"","lua_type":"boolean"}],"function_type":"method","source":{"line":322,"path":"src/init.luau"}},{"name":"gt","desc":"Checks if the state\'s value is greater than the value of `other`\\n\\nEquivalent to state:get() > other:get()\\n```lua\\nlocal a = Val.new(20)\\nlocal b = Val.new(30)\\nlocal c = Val.new(10)\\nlocal d = Val.new(20)\\nprint(a:gt(b)) -- false\\nprint(a:gt(c)) -- true\\nprint(a:gt(d)) -- false\\n```","params":[{"name":"other","desc":"","lua_type":"Val"}],"returns":[{"desc":"","lua_type":"boolean"}],"function_type":"method","source":{"line":344,"path":"src/init.luau"}},{"name":"ge","desc":"Checks if the state\'s value is greater than or equal to the value of `other`\\n\\nEquivalent to state:get() > other:get()\\n```lua\\nlocal a = Val.new(20)\\nlocal b = Val.new(30)\\nlocal c = Val.new(10)\\nlocal d = Val.new(20)\\nprint(a:ge(b)) -- false\\nprint(a:ge(c)) -- true\\nprint(a:ge(d)) -- true\\n```","params":[{"name":"other","desc":"","lua_type":"Val"}],"returns":[{"desc":"","lua_type":"boolean"}],"function_type":"method","source":{"line":366,"path":"src/init.luau"}},{"name":"on","desc":"Subscribes a callback to be called every time the state\'s value changes\\n```lua\\nlocal num = Val.new(10)\\nlocal disconnect = num:on(function(newValue)\\n\\tprint(\\"num set to:\\", newValue)\\nend)\\nnum:set(0) -- num set to: 0\\nnum:set(20) -- num set to: 20\\ndisconnect()\\nnum:set(10) -- no output\\n\\nlocal num = Val.new(10)\\nlocal disconnect = num:on(function(newValue, oldValue, wasCalledImmediately)\\n\\tprint(\\"was\\", oldValue, \\"- now\\", newValue, \\"-\\", wasCalledImmediately)\\nend, true) -- was 10 - now 10 - true\\nnum:set(0) -- was 10 now 0 false\\n```","params":[{"name":"callback","desc":"","lua_type":"(newValue: T, oldValue?: T, wasCalledImmediately?: boolean) -> ()"},{"name":"callImmediately","desc":"","lua_type":"boolean?"}],"returns":[{"desc":"calling this function will unsubscribe the callback from the state","lua_type":"disconnect: () -> ()"}],"function_type":"method","source":{"line":394,"path":"src/init.luau"}},{"name":"die","desc":"Destroys the state\\n```lua\\nlocal num = Val.new(10)\\nnum:set(20)\\nnum:die()\\nnum:set(0) -- error\\n\\nlocal bool = Val.new(true)\\nbool = bool:die() :: any -- sets bool to nil to ensure that it will be garbage collected\\n\\nlocal foo = Val.new(\\"foo\\")\\nfoo.bar = Val.new(\\"bar\\")\\nfoo:die() -- also destroys foo.bar\\n\\nlocal yep = Val.new(true)\\nlocal nope = Val.new(false)\\nyep.sike = nope\\nyep:die(true) -- nope is still alive\\n```","params":[{"name":"shallow","desc":"if true, any states stored inside the current state will be dereferenced rather than destroyed along with the current state","lua_type":"boolean?"}],"returns":[],"function_type":"method","source":{"line":433,"path":"src/init.luau"}},{"name":"isdead","desc":"Note: `Val.isdead(state)` behaves differently from `state:isdead()` to provide the same output, only if the state is dead\\n\\n`Val.isdead(state)` checks the metatable of the state while state:isdead() calls a metamethod to return true\\n```lua\\nlocal x = Val.new(true)\\nprint(x:isdead()) -- false\\nprint(Val.isdead(x)) -- false\\nx:die()\\nprint(x:isdead()) -- true\\nprint(Val.isdead(x)) -- true\\nprint(x:get()) -- error\\n```","params":[],"returns":[{"desc":"whether or not the state is dead","lua_type":"boolean"}],"function_type":"method","source":{"line":503,"path":"src/init.luau"}},{"name":"calc","desc":"Creates a computed state that automatically updates with its referenced states\\n\\nget (Val<T>) -> T -- inside the eval function, call get(state) instead of state:get() so dependent states are detected\\n\\nNote: If a dependent state is destroyed, then so will the computed\\n```lua\\nlocal length = Val.new(10)\\nlocal area = Val.calc(function(get)\\n\\tlocal side = get(length)\\n\\treturn side * side\\nend)\\nprint(area:get()) -- 10 * 10 -> 100\\nlength:set(20)\\nprint(area:get()) -- 20 * 20 -> 400\\n```","params":[{"name":"eval","desc":"a callback function that should return a new value derived from its dependent states","lua_type":"(get: (Val<any>) -> any) -> T"}],"returns":[{"desc":"an immutable state (Val:set() is disabled to enforce reactivity)","lua_type":"Val"}],"function_type":"static","source":{"line":526,"path":"src/init.luau"}},{"name":"batch","desc":"Batches a sequence of set calls so that observers are only called after all states are fully set\\n\\nset (Val<T>) -> T -- inside fn, call set(state) instead of state:set() so that the state change is batched instead of instant\\n```lua\\nlocal w = Val.new(6)\\nlocal h = Val.new(5)\\nlocal area = Val.calc(function(get)\\n\\treturn get(w) * get(h)\\nend)\\narea:on(function(new)\\n\\tprint(\\"The area is\\", new)\\nend)\\n\\nw:set(8) -- The area is 40\\nh:set(3) -- The area is 24\\n\\nVal.batch(function(set)\\n\\tset(w, 6) -- no output\\n\\tset(h, 5) -- no output\\nend) -- The area is 30\\n```","params":[{"name":"fn","desc":"a callback function where all the set calls should take place","lua_type":"(set) -> T"}],"returns":[],"function_type":"static","source":{"line":580,"path":"src/init.luau"}},{"name":"scope","desc":"Creates a state with no value, where `values` are stored as fields directly inside the state itself rather than in its value.\\n\\nWhen the scope state dies, all of its contents die with it unless a true is passed into the first optional parameter (state:die(true))\\n\\nAny value inside the scope table that isn\'t a Val object will be dereferenced rather than destroyed when the scope dies\\n\\nIf iterating through a scope, always use either generic iteration (for i, v in state do) or ipairs to avoid iterating through built-in keys.\\n```lua\\n-- Scope dictionary example\\nlocal rect = Val.scope {\\n\\tpos = Val.new(Vector2.new(6, 3)),\\n\\tsize = Val.new(Vector2.new(4, 2))\\n}\\nprint(rect:get()) -- nil\\nrect:die() -- pos and size also die\\n-- Equivalent to:\\nlocal rect = Val.none()\\nrect.pos = Val.new(Vector2.new(6, 3))\\nrect.size = Val.new(Vector2.new(4, 2))\\nprint(rect:get()) -- nil\\nrect:die() -- pos and size also die\\n\\n-- Scope array example\\nlocal waypoints = Val.scope {\\n\\tVal.new(Vector3.new(2, 6, -3)),\\n\\tVal.new(Vector3.new(9, -4, 8)),\\n\\tVal.new(Vector3.new(-5, 8, 2)),\\n\\tVal.new(Vector3.new(-7, 2, -1)),\\n}\\n\\nfor i, v in ipairs(waypoints) do\\n\\tprint(v:get().Magnitude)\\nend\\n\\nwaypoints:die() -- kills all the Vector3 states inside the scope\\n```","params":[{"name":"values","desc":"","lua_type":"{[any]: any}?"}],"returns":[{"desc":"","lua_type":"Val<nil>\\r\\n"}],"function_type":"static","source":{"line":638,"path":"src/init.luau"}},{"name":"none","desc":"Creates a state with no value, essentially creating a scope manually.\\n\\nEquivalent to Val.new(nil)\\n```lua\\nlocal rect = Val.none()\\nrect.size = Val.new(Vector2.new(2, 5))\\nrect.pos = Val.new(Vector2.new(9, -5))\\nrect:die() -- also destroys size and pos\\n```","params":[],"returns":[{"desc":"a state with no value","lua_type":"Val<nil>"}],"function_type":"static","source":{"line":661,"path":"src/init.luau"}},{"name":"copy","desc":"Creates a copy of the state\\n\\nThe cloned state will not be connected to any callbacks. This also means that a cloned states will not be connected to any computeds.\\n\\nThis method only creates a shallow copy, so states embedded inside the clone will be the same states as the original in memory.\\n\\nComputeds will use the same states as the original\\n```lua\\nlocal a = Val.new(0)\\na:on(function(value)\\n\\tprint(\\"set to\\", value)\\nend)\\nlocal b = a:copy()\\nprint(a == b) -- false\\nprint(a:eq(b)) -- true\\na:set(1) -- set to 1\\nb:set(2) -- no output\\nprint(a:get(), b:get()) -- 1, 2\\n```","params":[],"returns":[{"desc":"","lua_type":"Val"}],"function_type":"method","source":{"line":689,"path":"src/init.luau"}}],"properties":[],"types":[],"name":"Val","desc":"A unique thing about this library is that every object--whether it\'s a state, a computed, or a scope--is ultimately a Val object!","source":{"line":6,"path":"src/init.luau"}}')}}]);