"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[509],{5543:e=>{e.exports=JSON.parse('{"functions":[{"name":"new","desc":"Constructs a new state\\n```lua\\nlocal num = Val.new(20)\\nlocal str = Val.new(\\"Hello, World!\\")\\nlocal bool = Val.new(true)\\n```","params":[{"name":"value","desc":"","lua_type":"T"}],"returns":[{"desc":"","lua_type":"Val<T>\\n"}],"function_type":"static","source":{"line":107,"path":"src/init.luau"}},{"name":"set","desc":"Sets the value of the state\\n```lua\\nlocal num = Val.new(10)\\nnum:set(20)\\nlocal str = Val.new(\\"Foo\\")\\nstr:set(\\"Bar\\")\\n```","params":[{"name":"value","desc":"the new value of the state","lua_type":"T"},{"name":"forceSet","desc":"forces the method to execute anyway in case the old value is the same as the new value","lua_type":"boolean?"}],"returns":[{"desc":"","lua_type":"Val"}],"function_type":"method","source":{"line":129,"path":"src/init.luau"}},{"name":"get","desc":"```lua\\nlocal num = Val.new(10)\\nprint(num:get()) -- 10\\n```","params":[],"returns":[{"desc":"the value of the state","lua_type":"T"}],"function_type":"method","source":{"line":151,"path":"src/init.luau"}},{"name":"add","desc":"Increases state by `value`\\n\\n```lua\\nlocal num = Val.new(5)\\nnum:add(2) -- 5+2 -> 7\\n```","params":[{"name":"value","desc":"","lua_type":"any"},{"name":"forceSet","desc":"","lua_type":"boolean?"}],"returns":[{"desc":"","lua_type":"Val"}],"function_type":"method","source":{"line":168,"path":"src/init.luau"}},{"name":"sub","desc":"Decreases state by `value`\\n\\n```lua\\nlocal num = Val.new(5)\\nnum:sub(2) -- 5-2 -> 3\\n```","params":[{"name":"value","desc":"","lua_type":"any"},{"name":"forceSet","desc":"","lua_type":"boolean?"}],"returns":[{"desc":"","lua_type":"Val"}],"function_type":"method","source":{"line":186,"path":"src/init.luau"}},{"name":"mul","desc":"Multiplies state by `value`\\n\\n```lua\\nlocal num = Val.new(5)\\nnum:mul(2) -- 5*2 -> 10\\n```","params":[{"name":"value","desc":"","lua_type":"any"},{"name":"forceSet","desc":"","lua_type":"boolean?"}],"returns":[{"desc":"","lua_type":"Val"}],"function_type":"method","source":{"line":204,"path":"src/init.luau"}},{"name":"div","desc":"Divides state by `value`\\n\\n```lua\\nlocal num = Val.new(5)\\nnum:div(2) -- 5/2 -> 2.5\\n```","params":[{"name":"value","desc":"","lua_type":"any"},{"name":"forceSet","desc":"","lua_type":"boolean?"}],"returns":[{"desc":"","lua_type":"Val"}],"function_type":"method","source":{"line":222,"path":"src/init.luau"}},{"name":"idiv","desc":"Floor divides state by `value`\\n\\n```lua\\nlocal num = Val.new(5)\\nnum:idiv(2) -- 2 remainder 1 -> 2\\n```","params":[{"name":"value","desc":"","lua_type":"any"},{"name":"forceSet","desc":"","lua_type":"boolean?"}],"returns":[{"desc":"","lua_type":"Val"}],"function_type":"method","source":{"line":240,"path":"src/init.luau"}},{"name":"mod","desc":"Applies the modulus of state by `value`\\n\\n```lua\\nlocal num = Val.new(5)\\nnum:mod(2) -- 2 remainder 1 -> 1\\n```","params":[{"name":"value","desc":"","lua_type":"any"},{"name":"forceSet","desc":"","lua_type":"boolean?"}],"returns":[{"desc":"","lua_type":"Val"}],"function_type":"method","source":{"line":258,"path":"src/init.luau"}},{"name":"pow","desc":"Exponentiates state by `value`\\n\\n```lua\\nlocal num = Val.new(5)\\nnum:pow(2) -- 5^2 -> 25\\n```","params":[{"name":"value","desc":"","lua_type":"any"},{"name":"forceSet","desc":"","lua_type":"boolean?"}],"returns":[{"desc":"","lua_type":"Val"}],"function_type":"method","source":{"line":276,"path":"src/init.luau"}},{"name":"cat","desc":"Concatenates state by `value`\\n\\n```lua\\nlocal str = Val.new(\\"Hello, \\")\\nstr:cat(\\"World!\\") -- \\"Hello, \\" .. \\"World!\\" -> \\"Hello, World!\\"\\n```","params":[{"name":"value","desc":"","lua_type":"any"},{"name":"forceSet","desc":"","lua_type":"boolean?"}],"returns":[{"desc":"","lua_type":"Val"}],"function_type":"method","source":{"line":294,"path":"src/init.luau"}},{"name":"flip","desc":"Toggles the state\'s value (value = not value)\\n\\nUsing this method on a non-boolean state will convert it into a boolean state\\n\\n```lua\\nlocal bool = Val.new(true)\\nbool:flip() -- false\\nbool:flip():flip():flip() -- true -> false -> true\\n```","params":[],"returns":[{"desc":"","lua_type":"Val"}],"function_type":"method","source":{"line":313,"path":"src/init.luau"}},{"name":"min","desc":"Updates state to the smallest value\\n\\nDoes not support force set\\n\\n```lua\\nlocal num = Val.new(5)\\nnum:min(3) -- 3 < 5 -> 3\\nnum:min(2, 4, 6) -- 2 < 4 < 5 < 6 -> 2\\n```","params":[{"name":"...","desc":"","lua_type":"number"}],"returns":[{"desc":"","lua_type":"Val"}],"function_type":"method","source":{"line":333,"path":"src/init.luau"}},{"name":"max","desc":"Updates state to the largest value\\n\\nDoes not support force set\\n\\n```lua\\nlocal num = Val.new(5)\\nnum:max(3) -- 3 < 5 -> 5\\nnum:max(2, 4, 6) -- 2 < 4 < 5 < 6 -> 6\\n```","params":[{"name":"...","desc":"","lua_type":"number"}],"returns":[{"desc":"","lua_type":"Val"}],"function_type":"method","source":{"line":353,"path":"src/init.luau"}},{"name":"clamp","desc":"Clamps state between `min` and `max`\\n\\n```lua\\nlocal num = Val.new(3)\\nnum:clamp(4, 6) -- 3 < [4, 6] -> 4\\nnum:clamp(-2, 2) -- 4 < [-2, 2] -> 2\\n```","params":[{"name":"min","desc":"","lua_type":"number"},{"name":"max","desc":"","lua_type":"number"},{"name":"forceSet","desc":"","lua_type":"boolean?"}],"returns":[{"desc":"","lua_type":"Val"}],"function_type":"method","source":{"line":373,"path":"src/init.luau"}},{"name":"abs","desc":"Sets state to its absolute value\\n\\n```lua\\nlocal num = Val.new(3)\\nnum:abs() -- 3\\nnum:set(-4)\\nnum:abs() -- 4\\n```","params":[{"name":"forceSet","desc":"","lua_type":"boolean?"}],"returns":[{"desc":"","lua_type":"Val"}],"function_type":"method","source":{"line":392,"path":"src/init.luau"}},{"name":"floor","desc":"Rounds down state to the nearest integer\\n\\n```lua\\nlocal num = Val.new(3)\\nnum:floor() -- 3\\nnum:set(3.3)\\nnum:floor() -- 3\\nnum:set(3.7)\\nnum:floor() -- 3\\n```","params":[{"name":"forceSet","desc":"","lua_type":"boolean?"}],"returns":[{"desc":"","lua_type":"Val"}],"function_type":"method","source":{"line":413,"path":"src/init.luau"}},{"name":"ceil","desc":"Rounds up state to the nearest integer\\n\\n```lua\\nlocal num = Val.new(3)\\nnum:ceil() -- 3\\nnum:set(3.3)\\nnum:ceil() -- 4\\nnum:set(3.7)\\nnum:ceil() -- 4\\n```","params":[{"name":"forceSet","desc":"","lua_type":"boolean?"}],"returns":[{"desc":"","lua_type":"Val"}],"function_type":"method","source":{"line":434,"path":"src/init.luau"}},{"name":"round","desc":"Rounds state to the nearest integer\\n\\n```lua\\nlocal num = Val.new(3)\\nnum:round() -- 3\\nnum:set(3.3)\\nnum:round() -- 3\\nnum:set(3.7)\\nnum:round() -- 4\\n```","params":[{"name":"forceSet","desc":"","lua_type":"boolean?"}],"returns":[{"desc":"","lua_type":"Val"}],"function_type":"method","source":{"line":455,"path":"src/init.luau"}},{"name":"snap","desc":"Rounds state to the nearest `unit`\\n\\n```lua\\nlocal num = Val.new(3.3)\\nnum:snap(0.5) -- 3.5\\nnum:set(5.137)\\nnum:snap(0.01) -- 5.14\\nnum:set(1.25)\\nnum:set(2) -- 2\\n```","params":[{"name":"unit","desc":"","lua_type":"number"},{"name":"forceSet","desc":"","lua_type":"boolean?"}],"returns":[{"desc":"","lua_type":"Val"}],"function_type":"method","source":{"line":477,"path":"src/init.luau"}},{"name":"lerp","desc":"Interpolates state to `b` based on the factor `t`\\n\\n```lua\\nlocal num = Val.new(3)\\nnum:lerp(4, 0.5) -- 50% from 3 to 4 -> 3.5\\nnum:lerp(5, 1) -- 100% from 3.5 to 5 -> 5\\nnum:lerp(10, 0.4) -- 40% from 5 to 10 -> 7\\n```","params":[{"name":"b","desc":"The ending value","lua_type":"number"},{"name":"t","desc":"The interpolation factor, typically between 0 and 1","lua_type":"number"},{"name":"forceSet","desc":"","lua_type":"boolean?"}],"returns":[{"desc":"","lua_type":"Val"}],"function_type":"method","source":{"line":498,"path":"src/init.luau"}},{"name":"eq","desc":"Checks if the state\'s value is equal to the value of `other`\\n\\nEquivalent to state:get() == other:get()\\n```lua\\nlocal a = Val.new(10)\\nlocal b = Val.new(10)\\nlocal c = Val.new(20)\\nprint(a:eq(b)) -- true\\nprint(a:eq(c)) -- false\\n```","params":[{"name":"other","desc":"","lua_type":"Val"}],"returns":[{"desc":"","lua_type":"boolean"}],"function_type":"method","source":{"line":519,"path":"src/init.luau"}},{"name":"lt","desc":"Checks if the state\'s value is less than the value of `other`\\n\\nEquivalent to state:get() < other:get()\\n```lua\\nlocal a = Val.new(20)\\nlocal b = Val.new(30)\\nlocal c = Val.new(10)\\nlocal d = Val.new(20)\\nprint(a:lt(b)) -- true\\nprint(a:lt(c)) -- false\\nprint(a:lt(d)) -- false\\n```","params":[{"name":"other","desc":"","lua_type":"Val"}],"returns":[{"desc":"","lua_type":"boolean"}],"function_type":"method","source":{"line":541,"path":"src/init.luau"}},{"name":"le","desc":"Checks if the state\'s value is less than or equal to the value of `other`\\n\\nEquivalent to state:get() < other:get()\\n```lua\\nlocal a = Val.new(20)\\nlocal b = Val.new(30)\\nlocal c = Val.new(10)\\nlocal d = Val.new(20)\\nprint(a:le(b)) -- true\\nprint(a:le(c)) -- false\\nprint(a:le(d)) -- true\\n```","params":[{"name":"other","desc":"","lua_type":"Val"}],"returns":[{"desc":"","lua_type":"boolean"}],"function_type":"method","source":{"line":563,"path":"src/init.luau"}},{"name":"gt","desc":"Checks if the state\'s value is greater than the value of `other`\\n\\nEquivalent to state:get() > other:get()\\n```lua\\nlocal a = Val.new(20)\\nlocal b = Val.new(30)\\nlocal c = Val.new(10)\\nlocal d = Val.new(20)\\nprint(a:gt(b)) -- false\\nprint(a:gt(c)) -- true\\nprint(a:gt(d)) -- false\\n```","params":[{"name":"other","desc":"","lua_type":"Val"}],"returns":[{"desc":"","lua_type":"boolean"}],"function_type":"method","source":{"line":585,"path":"src/init.luau"}},{"name":"ge","desc":"Checks if the state\'s value is greater than or equal to the value of `other`\\n\\nEquivalent to state:get() > other:get()\\n```lua\\nlocal a = Val.new(20)\\nlocal b = Val.new(30)\\nlocal c = Val.new(10)\\nlocal d = Val.new(20)\\nprint(a:ge(b)) -- false\\nprint(a:ge(c)) -- true\\nprint(a:ge(d)) -- true\\n```","params":[{"name":"other","desc":"","lua_type":"Val"}],"returns":[{"desc":"","lua_type":"boolean"}],"function_type":"method","source":{"line":607,"path":"src/init.luau"}},{"name":"on","desc":"Subscribes a callback to be called every time the state\'s value changes\\n```lua\\nlocal num = Val.new(10)\\nlocal disconnect = num:on(function(newValue)\\n\\tprint(\\"num set to:\\", newValue)\\nend)\\nnum:set(0) -- num set to: 0\\nnum:set(20) -- num set to: 20\\ndisconnect()\\nnum:set(10) -- no output\\n\\nlocal num = Val.new(10)\\nlocal disconnect = num:on(function(newValue, oldValue, wasCalledImmediately)\\n\\tprint(\\"was\\", oldValue, \\"- now\\", newValue, \\"-\\", wasCalledImmediately)\\nend, true) -- was 10 - now 10 - true\\nnum:set(0) -- was 10 now 0 false\\n```","params":[{"name":"callback","desc":"","lua_type":"(newValue: T, oldValue?: T, wasCalledImmediately?: boolean) -> ()"},{"name":"callImmediately","desc":"","lua_type":"boolean?"}],"returns":[{"desc":"calling this function will unsubscribe the callback from the state","lua_type":"disconnect: () -> ()"}],"function_type":"method","source":{"line":635,"path":"src/init.luau"}},{"name":"die","desc":"Destroys the state\\n```lua\\nlocal num = Val.new(10)\\nnum:set(20)\\nnum:die()\\nnum:set(0) -- error\\n\\nlocal bool = Val.new(true)\\nbool = bool:die() :: any -- sets bool to nil to ensure that it will be garbage collected\\n\\nlocal foo = Val.new(\\"foo\\")\\nfoo.bar = Val.new(\\"bar\\")\\nfoo:die() -- also destroys foo.bar\\n\\nlocal yep = Val.new(true)\\nlocal nope = Val.new(false)\\nyep.sike = nope\\nyep:die(true) -- nope is still alive\\n```","params":[{"name":"shallow","desc":"if true, any states stored inside the current state will be dereferenced rather than destroyed along with the current state","lua_type":"boolean?"}],"returns":[],"function_type":"method","source":{"line":674,"path":"src/init.luau"}},{"name":"Destroy","desc":"An alias for `Val:die()` for better compatibility with cleanup libraries like [Janitor](https://howmanysmall.github.io/Janitor/)","params":[],"returns":[],"function_type":"method","source":{"line":733,"path":"src/init.luau"}},{"name":"isdead","desc":"Note: `Val.isdead(state)` behaves differently from `state:isdead()` to provide the same output, only if the state is dead\\n\\n`Val.isdead(state)` checks the metatable of the state while state:isdead() calls a metamethod to return true\\n```lua\\nlocal x = Val.new(true)\\nprint(x:isdead()) -- false\\nprint(Val.isdead(x)) -- false\\nx:die()\\nprint(x:isdead()) -- true\\nprint(Val.isdead(x)) -- true\\nprint(x:get()) -- error\\n```","params":[],"returns":[{"desc":"whether or not the state is dead","lua_type":"boolean"}],"function_type":"method","source":{"line":752,"path":"src/init.luau"}},{"name":"calc","desc":"Creates a computed state that automatically updates with its referenced states\\n\\nget (Val<T>) -> T -- inside the eval function, call get(state) instead of state:get() so dependent states are detected\\n\\nNote: If a dependent state is destroyed, then so will the computed\\n```lua\\nlocal length = Val.new(10)\\nlocal area = Val.calc(function(get)\\n\\tlocal side = get(length)\\n\\treturn side * side\\nend)\\nprint(area:get()) -- 10 * 10 -> 100\\nlength:set(20)\\nprint(area:get()) -- 20 * 20 -> 400\\n```","params":[{"name":"eval","desc":"a callback function that should return a new value derived from its dependent states","lua_type":"(get: (Val<any>) -> any) -> T"}],"returns":[{"desc":"an immutable state (Val:set() is disabled to enforce reactivity)","lua_type":"Val"}],"function_type":"static","source":{"line":775,"path":"src/init.luau"}},{"name":"batch","desc":"Batches a sequence of set calls so that observers are only called after all states are fully set\\n\\nset (Val<T>) -> T -- inside fn, call set(state) instead of state:set() so that the state change is batched instead of instant\\n```lua\\nlocal w = Val.new(6)\\nlocal h = Val.new(5)\\nlocal area = Val.calc(function(get)\\n\\treturn get(w) * get(h)\\nend)\\narea:on(function(new)\\n\\tprint(\\"The area is\\", new)\\nend)\\n\\nw:set(8) -- The area is 40\\nh:set(3) -- The area is 24\\n\\nVal.batch(function(set)\\n\\tset(w, 6) -- no output\\n\\tset(h, 5) -- no output\\nend) -- The area is 30\\n```","params":[{"name":"fn","desc":"a callback function where all the set calls should take place","lua_type":"(set) -> T"}],"returns":[],"function_type":"static","source":{"line":829,"path":"src/init.luau"}},{"name":"scope","desc":"Creates a state with no value, where `values` are stored as fields directly inside the state itself rather than in its value.\\n\\nWhen the scope state dies, all of its contents die with it unless a true is passed into the first optional parameter (state:die(true))\\n\\nAny value inside the scope table that isn\'t a Val object will be dereferenced rather than destroyed when the scope dies\\n\\nIf iterating through a scope, always use either generic iteration (for i, v in state do) or ipairs to avoid iterating through built-in keys.\\n```lua\\n-- Scope dictionary example\\nlocal rect = Val.scope {\\n\\tpos = Val.new(Vector2.new(6, 3)),\\n\\tsize = Val.new(Vector2.new(4, 2))\\n}\\nprint(rect:get()) -- nil\\nrect:die() -- pos and size also die\\n-- Equivalent to:\\nlocal rect = Val.none()\\nrect.pos = Val.new(Vector2.new(6, 3))\\nrect.size = Val.new(Vector2.new(4, 2))\\nprint(rect:get()) -- nil\\nrect:die() -- pos and size also die\\n\\n-- Scope array example\\nlocal waypoints = Val.scope {\\n\\tVal.new(Vector3.new(2, 6, -3)),\\n\\tVal.new(Vector3.new(9, -4, 8)),\\n\\tVal.new(Vector3.new(-5, 8, 2)),\\n\\tVal.new(Vector3.new(-7, 2, -1)),\\n}\\n\\nfor i, v in ipairs(waypoints) do\\n\\tprint(v:get().Magnitude)\\nend\\n\\nwaypoints:die() -- kills all the Vector3 states inside the scope\\n```","params":[{"name":"values","desc":"","lua_type":"{[any]: any}?"}],"returns":[{"desc":"","lua_type":"Val<nil>\\n"}],"function_type":"static","source":{"line":887,"path":"src/init.luau"}},{"name":"none","desc":"Creates a state with no value, essentially creating a scope manually.\\n\\nEquivalent to Val.new(nil)\\n```lua\\nlocal rect = Val.none()\\nrect.size = Val.new(Vector2.new(2, 5))\\nrect.pos = Val.new(Vector2.new(9, -5))\\nrect:die() -- also destroys size and pos\\n```","params":[],"returns":[{"desc":"a state with no value","lua_type":"Val<nil>"}],"function_type":"static","source":{"line":910,"path":"src/init.luau"}},{"name":"copy","desc":"Creates a copy of the state\\n\\nThe cloned state will not be connected to any callbacks. This also means that a cloned states will not be connected to any computeds.\\n\\nThis method only creates a shallow copy, so states embedded inside the clone will be the same states as the original in memory.\\n\\nComputeds will use the same states as the original\\n```lua\\nlocal a = Val.new(0)\\na:on(function(value)\\n\\tprint(\\"set to\\", value)\\nend)\\nlocal b = a:copy()\\nprint(a == b) -- false\\nprint(a:eq(b)) -- true\\na:set(1) -- set to 1\\nb:set(2) -- no output\\nprint(a:get(), b:get()) -- 1, 2\\n```","params":[],"returns":[{"desc":"","lua_type":"Val"}],"function_type":"method","source":{"line":938,"path":"src/init.luau"}}],"properties":[],"types":[{"name":"Type<T>","desc":"An alias for `Val<T>` so you can write `Val.Type<T>` instead of `Val.Val<T>` in external scripts\\n```lua\\nlocal Val = require(path.to.Val)\\nlocal num: Val.Type<number> = Val.new(2.718)\\n```","lua_type":"Val<T>","source":{"line":33,"path":"src/init.luau"}},{"name":"Val<T>","desc":"Here are the internals of a Val object! You really don\'t have to understand any of this to know how to use Val,\\nbut it\'s here in case you need to do some hacky operations.\\n```lua\\nlocal Val = require(path.to.Val)\\nlocal num: Val.Val<number> = Val.new(3.141)\\n```","lua_type":"@metatable {_value: T, _listeners: {(T, T, boolean) -> ()}, _dependents: {Val<any>}, _disconnects: {[Val<any>]: () -> ()}?, _eval<U>: (((Val<U>) -> U) -> T)?, [any]: any}","source":{"line":45,"path":"src/init.luau"}}],"name":"Val","desc":"","source":{"line":7,"path":"src/init.luau"}}')}}]);