"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[182],{1886:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>r,contentTitle:()=>i,default:()=>h,frontMatter:()=>d,metadata:()=>a,toc:()=>o});const a=JSON.parse('{"id":"destroy","title":"Destroying States","description":"To destroy a state, simply use Valisdead() or Val.isdead(Val) (all methods can be called as static such as Val.set(Val, T)):","source":"@site/docs/destroy.md","sourceDirName":".","slug":"/destroy","permalink":"/Val/docs/destroy","draft":false,"unlisted":false,"editUrl":"https://github.com/TumbleWede/Val/edit/main/docs/destroy.md","tags":[],"version":"current","sidebarPosition":6,"frontMatter":{"sidebar_position":6},"sidebar":"defaultSidebar","previous":{"title":"Scopes","permalink":"/Val/docs/scopes"},"next":{"title":"Cloning States","permalink":"/Val/docs/cloning"}}');var s=n(4848),l=n(8453);const d={sidebar_position:6},i="Destroying States",r={},o=[];function c(e){const t={a:"a",admonition:"admonition",code:"code",h1:"h1",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,l.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t.header,{children:(0,s.jsx)(t.h1,{id:"destroying-states",children:"Destroying States"})}),"\n",(0,s.jsx)(t.h1,{id:"usage",children:"Usage"}),"\n",(0,s.jsxs)(t.p,{children:["To destroy a state, simply use ",(0,s.jsx)(t.code,{children:"Val:die()"}),". To check if a state has been destroyed, call either ",(0,s.jsx)(t.code,{children:"Val:isdead()"})," or ",(0,s.jsx)(t.code,{children:"Val.isdead(Val<T>)"})," (all methods can be called as static such as ",(0,s.jsx)(t.code,{children:"Val.set(Val<T>, T)"}),"):"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-lua",children:"local x = Val.new(20)\nx:set(30)\nprint(x:isdead()) -- false\nx:die()\nx:set(40) -- error\nprint(x:isdead()) -- true\n"})}),"\n",(0,s.jsxs)(t.p,{children:["After a value has been destroyed, you can no longer use its methods other than ",(0,s.jsx)(t.code,{children:"Val:die()"})," and ",(0,s.jsx)(t.code,{children:"Val:isdead()"}),". All of its contents will be removed, and trying to access any fields may result in an error."]}),"\n",(0,s.jsx)(t.p,{children:"If a computed is dependent on a state that has been destroyed, then the computed will also be destroyed:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-lua",children:"local side = Val.new(5)\nlocal area = Val.calc(function(get)\n\treturn get(side) ^ 2\nend)\n\nprint(side:isdead()) -- false\nprint(area:isdead()) -- false\nside:die()\nprint(side:isdead()) -- true\nprint(area:isdead()) -- true\n"})}),"\n",(0,s.jsx)(t.admonition,{type:"tip",children:(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.code,{children:"Val:Destroy()"})," is an alias for ",(0,s.jsx)(t.code,{children:"Val:die()"})," for better compatibility with cleanup libraries like ",(0,s.jsx)(t.a,{href:"https://howmanysmall.github.io/Janitor/",children:"Janitor"})]})}),"\n",(0,s.jsx)(t.h1,{id:"destroying-scopes",children:"Destroying Scopes"}),"\n",(0,s.jsxs)(t.p,{children:["By default, all states inside the dying state will be destroyed along with the state. Alternatively, you can call ",(0,s.jsx)(t.code,{children:"Val:die(true)"}),", where the ",(0,s.jsx)(t.code,{children:"true"})," argument indicates that all internal states will be dereferenced rather than destroyed:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-lua",children:"local t1 = Val.new({\n\tVal.new(1),\n\tVal.new(2),\n\tVal.new(3)\n})\nt1:die() -- 1, 2, and 3 states will also be destroyed\n\nlocal t2 = Val.scope {\n\tVal.new(1),\n\tVal.new(2),\n\tVal.new(3),\n\ta = Val.new(1),\n\tb = Val.new(2),\n\tc = Val.new(3),\n}\nt2:die() -- All six states will be destroyed\n\nlocal x = Val.new(1)\nlocal t3 = Val.scope {\n\ta = x,\n\tb = Val.new(2),\n\tc = Val.new(3),\n}\nt3:die() -- a, b, and c will be destroyed.\nprint(x:isdead()) -- true\n\nlocal y = Val.new(1)\nlocal t4 = Val.scope {\n\ta = y,\n\tb = Val.new(2),\n\tc = Val.new(3),\n}\nt4:die(true) -- a, b, and c will be dereferenced but alive.\n-- y will remain alive, but the values of t4.b and t4.c will be garbage collected\n"})}),"\n",(0,s.jsxs)(t.admonition,{type:"note",children:[(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.code,{children:"Val:isdead()"})," and ",(0,s.jsx)(t.code,{children:"Val.isdead(Val<T>)"})," return the same result, but the two behave differently if the state is dead."]}),(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.code,{children:"Val.isdead(Val<T>)"})," will compare the metatable of the state to the metatable of a dead state"]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.code,{children:"Val:isdead()"})," is an exception for accessing methods of a dead state, in which the ",(0,s.jsx)(t.code,{children:"__index"})," metamethod will refer to a function that returns true."]}),"\n"]}),(0,s.jsxs)(t.p,{children:["If the state is alive, ",(0,s.jsx)(t.code,{children:"Val:isdead()"})," will refer to ",(0,s.jsx)(t.code,{children:"Val.isdead(self)"}),"."]})]})]})}function h(e={}){const{wrapper:t}={...(0,l.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}},8453:(e,t,n)=>{n.d(t,{R:()=>d,x:()=>i});var a=n(6540);const s={},l=a.createContext(s);function d(e){const t=a.useContext(l);return a.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function i(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:d(e.components),a.createElement(l.Provider,{value:t},e.children)}}}]);