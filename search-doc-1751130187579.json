{"searchDocs":[{"title":"Operator Methods","type":0,"sectionRef":"#","url":"/Val/docs/operations","content":"Operator Methods Val has many operator methods that help reduce the code needed to perform operations on Val object. Using these operator methods also reduces the number of calls per operation, thus being more efficient than performing them manually (as seen in the Val equivalents). These methods will not check if the operation is valid, so trying to do something devious like dividing a string will result in an error. Assignment Operators Assume a is a Val&lt;T&gt; and b is a T, where T is any type. If b were to be a Val&lt;T&gt;, then you would need to call b:get() inside each assignment call (e.g. a:add(b:get())). Name\tOperator\tVal Method\tVal EquivalentAddition\ta += b\ta:add(b)\ta:set(a:get() + b) Subtraction\ta -= b\ta:sub(b)\ta:set(a:get() - b) Multiplication\ta *= b\ta:mul(b)\ta:set(a:get() * b) Division\ta /= b\ta:div(b)\ta:set(a:get() / b) Floor Division\ta //= b\ta:idiv(b)\ta:set(a:get() // b) Modulus\ta %= b\ta:mod(b)\ta:set(a:get() % b) Exponentiation\ta ^= b\ta:pow(b)\ta:set(a:get() ^ b) Concatenation\ta ..= b\ta:cat(b)\ta:set(a:get() .. b) Toggling\ta = not a\ta:flip()\ta:set(not a:get()) Relational Operators Assume both a and b are a Val&lt;T&gt;, since these methods are meant to be used exclusively for comparing Val objects. Name\tOperator\tVal Method\tVal EquivalentEqual to\ta == b\ta:eq(b)\ta:get() == b:get() Less than\ta &lt; b\ta:lt(b)\ta:get() &lt; b:get() Less than or equal to\ta &lt;= b\ta:le(b)\ta:get() &lt;= b:get() Greater than\ta &gt; b\ta:gt(b)\ta:get() &gt; b:get() Greater than or equal to\ta &gt;= b\ta:ge(b)\ta:get() &gt;= b:get()","keywords":"","version":"Next"},{"title":"Batching","type":0,"sectionRef":"#","url":"/Val/docs/batching","content":"Batching Val supports batching, where we can set multiple states in a batch that will only call observers after all the values have been set. Let's look at a basic example of setting a state without batching: local x = Val.new(2) x:on(function(value) print(&quot;x set to&quot;, value) end) x:set(3) -- x set to 3 x:set(4) -- x set to 4 x:set(5) -- x set to 5 In this case, the observer will be called after each set. Now let's do the same thing but with batching: local x = Val.new(2) x:on(function(value) print(&quot;x set to&quot;, value) end) Val.batch(function(set) set(x, 3) -- no output set(x, 4) -- no output set(x, 5) -- no output end) -- x set to 5 This time, setting the value of x will not call the observer until after the batch is done. This means that the observer will only be called once instead of three times. The Val.batch function took in a callback function as the argument, which took in a set function. The set(Val&lt;T&gt;, T) function allows us to set the value of the state without immediately calling the observer. If Val:set were to be used inside the batch callback, then the observer would immediately be called. note You cannot use any of the assignment operator methods inside the batch, as just like Val:set, they would immediately call the observer inside the batch. You would have to set the value manually, so a:add(b) would look like set(a, a:get() + b)Computeds cannot be batched because of their reliance on observers. As mentioned previously about redundant updates when chaining computeds, there is not a way to solve it with batching in Val.","keywords":"","version":"Next"},{"title":"Cloning States","type":0,"sectionRef":"#","url":"/Val/docs/cloning","content":"Cloning States Usage Use Val:copy() to clone a state: local a = Val.new(20) local b = a:copy() print(a == b) -- false (implying b is a separate state) print(a:eq(b)) -- true a:set(10) print(b:get()) -- 20 However, Val:copy() only creates a shallow clone of the state. This means that any object, including internal states, will share the same reference: local t1 = Val.scope { Val.new(1), Val.new(2), Val.new(3) } local t2 = t1:copy() t2[1]:die() print(t1[1]:isdead()) -- true note Val currently does not support deep cloning, but this is subject to change in the future if it becomes a significant limitation.","keywords":"","version":"Next"},{"title":"Observers","type":0,"sectionRef":"#","url":"/Val/docs/observers","content":"Observers Usage Observers are event listeners that are called whenever the state changes its value: local x = Val.new(2) local disconnect = x:on(function(newValue, oldValue, wasCalledImmediately) print(newValue, oldValue, wasCalledImmediately) end, true) -- 2 2 true x:set(4) -- 4 2 false x:set(8) -- 8 4 false x:set(8) -- no output because value did not change x:set(8, true) -- 8 8 false disconnect() x:set(16) -- no output We created an observer by calling the Val:on method, which takes in a callback function and an optional boolean. The callback function takes in three optional values: newValue - the state's newly updated valueoldValue - the state's previous valuewasCalledImmediately - if the callback was called immediately In most cases, you will only need newValue. The second optional parameter, if set to true, indicates that we want to call the observer immediately. If false or nil, the observer will not be called until the next state update. The Val:on method returns a disconnect callback. When we no longer need to listen to a value, we can call this disconnect. In the example above, our observer would display any changes of the value of x, but this observer is destroyed after we called disconnect() In the example above, we used Val:set with a second optional boolean parameter that, when true, would cause the method to call its observers even if the value did not actually change.","keywords":"","version":"Next"},{"title":"Intro","type":0,"sectionRef":"#","url":"/Val/docs/intro","content":"Intro In this page, I will introduce the basics of Val, but the principles can be applied to most state libraries. Let's begin by creating some simple logic: local num = 20 num = 40 print(num) -- 40 In the example above, all we did was create a number, modify it, and print its value. Now let's do the same thing using Val: local num = Val.new(20) num:set(40) print(num:get()) -- 40 This time, num is a state object and not a primitive. To set the value, we simply use the set method. To get the value, we just use get. Now, let's try a more legitimate example: local label = script.Parent.TextLabel -- assume this exists local num = 20 label.Text = &quot;Number: &quot; .. num -- Number: 20 num = 40 label.Text = &quot;Number: &quot; .. num -- Number: 40 num = 70 label.Text = &quot;Number: &quot; .. num -- Number: 70 One issue with this logic is that we have to manually update label.Text every time we change num because it is a primitive that cannot be observed. Now let's try the same thing with Val: local label = script.Parent.TextLabel -- assume this exists local num = Val.new(20) num:on(function(value) label.Text = &quot;Number: &quot; .. num end, true) -- Number: 20 num:set(40) -- Number: 40 num:set(70) -- Number: 70 Now, all we have to do is change the value of num, and label.Text will automatically update through the on method. Although code this small may not demand the use of a state container library like Val, synchronizing values with displays in large codebases can quickly become messy. Luckily, state container libraries like Val make this synchronization much more manageable. In the next pages, I will talk more about how to use the features of Val.","keywords":"","version":"Next"},{"title":"Computeds","type":0,"sectionRef":"#","url":"/Val/docs/computeds","content":"Computeds Usage This library supports computed states, which are essentially states whose values are derived from dependent states. When a dependent state changes, the computed state will automatically update along with it. This means that you cannot change the value of a computed state manually. Let's look at a basic example: local a = Val.new(3) local b = Val.new(4) local h = Val.calc(function(get) return math.sqrt(get(a)^2 + get(b)^2) end) print(h:get()) -- 5 a:set(6) b:set(8) print(h:get()) -- 10 In this example, we created a computed that calculates the hypotenuse, h, of a right triangle based on the side lengths, a and b. We used the Val.calc constructor to create the computed, which we passed in a callback function as the argument. This function will return the value of the computed based on the values of the other states we want to use (a and b in this case). When a or b updates its value, the callback will be called, thus allowing it to update its value. Notice how the callback takes in a function called get that we use instead of the Val:get() method. This special get function tells the computed which values it depends on, so if we just used a:get() instead of get(a), then h would not update if the value of a were to change. Let's look at another triangle example below: local a, b, c = Val.new(3), Val.new(4), Val.new(5) local s = Val.calc(function(get) return (get(a) + get(b) + get(c)) / 2 end) -- A = sqrt(s * (s-a) * (s-b) * (s-c)), where s = (a+b+c) / 2 local area = Val.calc(function(get) local s2 = get(s) return math.sqrt(s2 * (s2 - get(a)) * (s2 - get(b)) * (s2 - get(c))) end) print(area:get()) -- 6 a:set(6) b:set(8) c:set(10) print(area:get()) -- 24 This example represents Heron's Formula, which calculates the area of a triangle given only its three side lengths. However, this formula needs a variable, s, which is equal to half of the sum of the three side lengths. Luckily, we can accomplish this using a computed, so we never have to worry about updating s when we need to update one of the side lengths. Computed states are still considered states, which means that we can also use them in other computeds. In this example, we used the computed s inside the computed area. This means that when a side length changes, s will update which will also update area. note Although chaining computeds like this is possible, there is one drawback, where the final computed may fire multiple times rather than once. In this case, if we set the value of a side length, s will update, but since area depends on both the side lengths AND s, this means that area will update twice instead of once. For small calculations like in this example, it's not really a problem, but if you were to have expensive computeds, it would be better to avoid this practice. Observer Behavior with Computeds","keywords":"","version":"Next"},{"title":"Destroying States","type":0,"sectionRef":"#","url":"/Val/docs/destroy","content":"Destroying States Usage To destroy a state, simply use Val:die(). To check if a state has been destroyed, call either Val:isdead() or Val.isdead(Val&lt;T&gt;) (all methods can be called as static such as Val.set(Val&lt;T&gt;, T)): local x = Val.new(20) x:set(30) print(x:isdead()) -- false x:die() x:set(40) -- error print(x:isdead()) -- true After a value has been destroyed, you can no longer use its methods other than Val:die() and Val:isdead(). All of its contents will be removed, and trying to access any fields may result in an error. If a computed is dependent on a state that has been destroyed, then the computed will also be destroyed: local side = Val.new(5) local area = Val.calc(function(get) return get(side) ^ 2 end) print(side:isdead()) -- false print(area:isdead()) -- false side:die() print(side:isdead()) -- true print(area:isdead()) -- true Destroying Scopes By default, all states inside the dying state will be destroyed along with the state. Alternatively, you can call Val:die(true), where the true argument indicates that all internal states will be dereferenced rather than destroyed: local t1 = Val.new({ Val.new(1), Val.new(2), Val.new(3) }) t1:die() -- 1, 2, and 3 states will also be destroyed local t2 = Val.scope { Val.new(1), Val.new(2), Val.new(3), a = Val.new(1), b = Val.new(2), c = Val.new(3), } t2:die() -- All six states will be destroyed local x = Val.new(1) local t3 = Val.scope { a = x, b = Val.new(2), c = Val.new(3), } t3:die() -- a, b, and c will be destroyed. print(x:isdead()) -- true local y = Val.new(1) local t4 = Val.scope { a = y, b = Val.new(2), c = Val.new(3), } t4:die(true) -- a, b, and c will be dereferenced but alive. -- y will remain alive, but the values of t4.b and t4.c will be garbage collected note Val:isdead() and Val.isdead(Val&lt;T&gt;) return the same result, but the two behave differently if the state is dead. Val.isdead(Val&lt;T&gt;) will compare the metatable of the state to the metatable of a dead stateVal:isdead() is an exception for accessing methods of a dead state, in which the __index metamethod will refer to a function that returns true. If the state is alive, Val:isdead() will refer to Val.isdead(self).","keywords":"","version":"Next"},{"title":"Scopes","type":0,"sectionRef":"#","url":"/Val/docs/scopes","content":"Scopes Intro In Val, scopes are Val objects with no value with the intention of storing other values. Before we dive into using Val.scope, let's first create a Val with fields: local rect = Val.new({ size = Val.new(Vector2.new(5, 3)), pos = Val.new(Vector2.new(6, 12)) }) In this example, we created a state with fields size and pos. However, we must call Val:get to access these fields (e.g. rect:get().size). We can skip this step by adding the fields directly inside the state object rather than inside the state's value: local rect = Val.none() -- alias for Val.new(nil) rect.size = Val.new(Vector2.new(5, 3)) rect.pos = Val.new(Vector2.new(6, 12)) This time, we can directly access size and pos (e.g. rect.size) without the need of rect:get(). Val does not stop you from modifying or accessing keys inside any states (unless the state is dead), so we can get away with this safely as long as we don't override any internal/private fields. warning Avoid adding custom fields with the following names: _value, _listeners, _dependents, _disconnects, _eval, and set Using Val.scope Now let's do the same thing using Val.scope: local rect = Val.scope { size = Val.new(Vector2.new(5, 3)), pos = Val.new(Vector2.new(6, 12)) } This code example will give us the same result as the previous example: a valueless state with custom fields. The benefit of using Val.scope instead of Val.none() is that you can store your custom fields in a table argument. For dictionaries, using Val.scope or Val.none() is based on your preference, but you will absolutely need to use Val.scope for arrays: local nums = Val.scope { Val.new(1), Val.new(2), Val.new(3), Val.new(4) } In this example, the list of states will be directly inside nums rather than inside its value. Iteration You can safely iterate through a scope's keys without iterating through the state's private fields: local t = Val.scope { a = Val.new(1), b = Val.new(2), c = Val.new(3) } for i, v in t do print(i, v:get()) end -- a 1 -- b 2 -- c 3 Because we used generic iteration, the for loop utilized the scope's iteration metamethod which will ensure that private keys will not be iterated through. Now let's do the same thing for an array: local t = Val.scope { Val.new(7), Val.new(8), Val.new(9) } for i, v in ipairs(t) do print(i, v:get()) end -- 1 7 -- 2 8 -- 3 9 In this example, we used ipairs instead of generic iteration to iterate through the indices. Although generic iteration could have produced the exact same result, ipairs is faster. tip Always use ipairs over generic iteration if you only need to use the index-value pairs and not key-value pairs. danger Using pairs will iterate through the state's private keys, which can lead to undefined behavior. Always use either ipairs or generic iteration for scopes. Now let's do an example of combining numeric and string keys in the scope. In this case, there is a significant difference in each iteration method: local t = Val.scope { a = Val.new(1), b = Val.new(2), c = Val.new(3), Val.new(7), Val.new(8), Val.new(9) } -- generic iteration for i, v in t do print(i, v:get()) end -- 1 7 -- 2 8 -- 3 9 -- a 1 -- b 2 -- c 3 -- ipairs for i, v in ipairs(t) do print(i, v:get()) end -- 1 7 -- 2 8 -- 3 9 -- pairs (why you should avoid this) for i, v in pairs(t) do print(i, v:get()) end -- 1 7 -- 2 8 -- 3 9 -- a 1 -- error: attempt to call missing method 'get' of table In this example, all three iterator methods produced a different result: Generic iteration printed every custom key-value/index-value pairipairs only printed every index-value pairpairs resulted in an error after the for loop tried to access a private key and assumed it was a state Observer Behavior with Scopes note Val currently does not have special observer behavior for scopes, but this is subject to change in the future if it becomes a significant limitation. Observers do not work directly on scopes because they listen to the value of the scope, which is typically just nil. However, you can simply overcome this by adding observers to the fields and not the scope: local rect = Val.scope { pos = Val.new(Vector2.new(2, 6)), size = Val.new(Vector2.new(4, 3)) } local onChange = function() print(&quot;Rectangle of size&quot;, rect.size:get(), &quot;located at&quot;, rect.pos:get()) end rect.pos:on(onChange) rect.size:on(onChange, true) -- Rectangle of size 4, 3 located at 2, 6 rect.pos:set(Vector2.new(5, 10)) -- Rectangle of size 4, 3 located at 5, 10 rect.size:set(Vector2.new(1, 2)) -- Rectangle of size 1, 2 located at 5, 10 When working with an unknown list of index-value pairs, we can use a table to keep track of observers for each index: local list = Val.scope { Val.new(1), Val.new(2), Val.new(3) } local onChange = function() local sum = 0 for i, v in ipairs(list) do sum += v:get() end print(&quot;The sum of the values of the list is&quot;, sum) end local observers = {} for i, v in ipairs(list) do observers[i] = v:on(onChange) end list[1]:set(list[1]:get(), true) -- Force update the value to immediately call the observer once -- The sum of the values of the list is 6 list[2]:set(10) -- The sum of the values of the list is 14 -- Destroy scope for i, v in ipairs(observers) do v() end observers = nil -- Also dereferences the disconnects list:die() -- Also destroys the three values tip Remember that you only need to use Val when you care about observing/reacting to value changes. If you have a field that you don't need to actively listen to, it does not need to be a Val object. You also only really need to use a scope rather than a regular table if/when you plan on destroying all the internal states at once for memory management purposes.","keywords":"","version":"Next"},{"title":"Val","type":0,"sectionRef":"#","url":"/Val/api/Val","content":"","keywords":"","version":null},{"title":"Functions​","type":1,"pageTitle":"Val","url":"/Val/api/Val#functions","content":" ","version":null,"tagName":"h2"},{"title":"new​","type":1,"pageTitle":"Val","url":"/Val/api/Val#new","content":"&lt;/&gt; Val.new(value: T) → Val&lt;T&gt; Constructs a new state local num = Val.new(20) local str = Val.new(&quot;Hello, World!&quot;) local bool = Val.new(true)   ","version":null,"tagName":"h3"},{"title":"calc​","type":1,"pageTitle":"Val","url":"/Val/api/Val#calc","content":"&lt;/&gt; Val.calc( eval: (get: (Val&lt;any&gt;) → any) → T-- a callback function that should return a new value derived from its dependent states ) → Val-- an immutable state (Val:set() is disabled to enforce reactivity) Creates a computed state that automatically updates with its referenced states get (Val) -&gt; T -- inside the eval function, call get(state) instead of state:get() so dependent states are detected Note: If a dependent state is destroyed, then so will the computed local length = Val.new(10) local area = Val.calc(function(get) local side = get(length) return side * side end) print(area:get()) -- 10 * 10 -&gt; 100 length:set(20) print(area:get()) -- 20 * 20 -&gt; 400   ","version":null,"tagName":"h3"},{"title":"batch​","type":1,"pageTitle":"Val","url":"/Val/api/Val#batch","content":"&lt;/&gt; Val.batch( fn: (set) → T-- a callback function where all the set calls should take place ) → () Batches a sequence of set calls so that observers are only called after all states are fully set set (Val) -&gt; T -- inside fn, call set(state) instead of state:set() so that the state change is batched instead of instant local w = Val.new(6) local h = Val.new(5) local area = Val.calc(function(get) return get(w) * get(h) end) area:on(function(new) print(&quot;The area is&quot;, new) end) w:set(8) -- The area is 40 h:set(3) -- The area is 24 Val.batch(function(set) set(w, 6) -- no output set(h, 5) -- no output end) -- The area is 30   ","version":null,"tagName":"h3"},{"title":"scope​","type":1,"pageTitle":"Val","url":"/Val/api/Val#scope","content":"&lt;/&gt; Val.scope(values: {[any]: any}?) → Val&lt;nil&gt; Creates a state with no value, where values are stored as fields directly inside the state itself rather than in its value. When the scope state dies, all of its contents die with it unless a true is passed into the first optional parameter (state:die(true)) Any value inside the scope table that isn't a Val object will be dereferenced rather than destroyed when the scope dies If iterating through a scope, always use either generic iteration (for i, v in state do) or ipairs to avoid iterating through built-in keys. -- Scope dictionary example local rect = Val.scope { pos = Val.new(Vector2.new(6, 3)), size = Val.new(Vector2.new(4, 2)) } print(rect:get()) -- nil rect:die() -- pos and size also die -- Equivalent to: local rect = Val.none() rect.pos = Val.new(Vector2.new(6, 3)) rect.size = Val.new(Vector2.new(4, 2)) print(rect:get()) -- nil rect:die() -- pos and size also die -- Scope array example local waypoints = Val.scope { Val.new(Vector3.new(2, 6, -3)), Val.new(Vector3.new(9, -4, 8)), Val.new(Vector3.new(-5, 8, 2)), Val.new(Vector3.new(-7, 2, -1)), } for i, v in ipairs(waypoints) do print(v:get().Magnitude) end waypoints:die() -- kills all the Vector3 states inside the scope   ","version":null,"tagName":"h3"},{"title":"none​","type":1,"pageTitle":"Val","url":"/Val/api/Val#none","content":"&lt;/&gt; Val.none() → Val&lt;nil&gt;-- a state with no value Creates a state with no value, essentially creating a scope manually. Equivalent to Val.new(nil) local rect = Val.none() rect.size = Val.new(Vector2.new(2, 5)) rect.pos = Val.new(Vector2.new(9, -5)) rect:die() -- also destroys size and pos   ","version":null,"tagName":"h3"},{"title":"set​","type":1,"pageTitle":"Val","url":"/Val/api/Val#set","content":"&lt;/&gt; Val:set( value: T,-- the new value of the state forceSet: boolean?-- forces the method to execute anyway in case the old value is the same as the new value ) → () Sets the value of the state local num = Val.new(10) num:set(20) local str = Val.new(&quot;Foo&quot;) str:set(&quot;Bar&quot;)   ","version":null,"tagName":"h3"},{"title":"get​","type":1,"pageTitle":"Val","url":"/Val/api/Val#get","content":"&lt;/&gt; Val:get() → T-- the value of the state local num = Val.new(10) print(num:get()) -- 10   ","version":null,"tagName":"h3"},{"title":"add​","type":1,"pageTitle":"Val","url":"/Val/api/Val#add","content":"&lt;/&gt; Val:add(value: any) → Val Increases state by value Note: Val does not check if the state's type supports this operation local num = Val.new(5) num:add(2) -- 5+2 -&gt; 7   ","version":null,"tagName":"h3"},{"title":"sub​","type":1,"pageTitle":"Val","url":"/Val/api/Val#sub","content":"&lt;/&gt; Val:sub(value: any) → Val Decreases state by value Note: Val does not check if the state's type supports this operation local num = Val.new(5) num:sub(2) -- 5-2 -&gt; 3   ","version":null,"tagName":"h3"},{"title":"mul​","type":1,"pageTitle":"Val","url":"/Val/api/Val#mul","content":"&lt;/&gt; Val:mul(value: any) → Val Multiplies state by value Note: Val does not check if the state's type supports this operation local num = Val.new(5) num:mul(2) -- 5*2 -&gt; 10   ","version":null,"tagName":"h3"},{"title":"div​","type":1,"pageTitle":"Val","url":"/Val/api/Val#div","content":"&lt;/&gt; Val:div(value: any) → Val Divides state by value Note: Val does not check if the state's type supports this operation local num = Val.new(5) num:div(2) -- 5/2 -&gt; 2.5   ","version":null,"tagName":"h3"},{"title":"idiv​","type":1,"pageTitle":"Val","url":"/Val/api/Val#idiv","content":"&lt;/&gt; Val:idiv(value: any) → Val Floor divides state by value Note: Val does not check if the state's type supports this operation local num = Val.new(5) num:idiv(2) -- 2 remainder 1 -&gt; 2   ","version":null,"tagName":"h3"},{"title":"mod​","type":1,"pageTitle":"Val","url":"/Val/api/Val#mod","content":"&lt;/&gt; Val:mod(value: any) → Val Applies the modulus of state by value Note: Val does not check if the state's type supports this operation local num = Val.new(5) num:mod(2) -- 2 remainder 1 -&gt; 1   ","version":null,"tagName":"h3"},{"title":"pow​","type":1,"pageTitle":"Val","url":"/Val/api/Val#pow","content":"&lt;/&gt; Val:pow(value: any) → Val Exponentiates state by value Note: Val does not check if the state's type supports this operation local num = Val.new(5) num:pow(2) -- 5^2 -&gt; 25   ","version":null,"tagName":"h3"},{"title":"cat​","type":1,"pageTitle":"Val","url":"/Val/api/Val#cat","content":"&lt;/&gt; Val:cat(value: any) → Val Concatenates state by value Note: Val does not check if the state's type supports this operation local str = Val.new(&quot;Hello, &quot;) str:cat(&quot;World!&quot;) -- &quot;Hello, &quot; .. &quot;World!&quot; -&gt; &quot;Hello, World!&quot;   ","version":null,"tagName":"h3"},{"title":"flip​","type":1,"pageTitle":"Val","url":"/Val/api/Val#flip","content":"&lt;/&gt; Val:flip() → Val Toggles the state's value (value = not value) Using this method on a non-boolean state will convert it into a boolean state Note: Val does not check if the state's type supports this operation local bool = Val.new(true) bool:flip() -- false bool:flip():flip():flip() -- true -&gt; false -&gt; true   ","version":null,"tagName":"h3"},{"title":"eq​","type":1,"pageTitle":"Val","url":"/Val/api/Val#eq","content":"&lt;/&gt; Val:eq(other: Val) → boolean Checks if the state's value is equal to the value of other Equivalent to state:get() == other:get() local a = Val.new(10) local b = Val.new(10) local c = Val.new(20) print(a:eq(b)) -- true print(a:eq(c)) -- false   ","version":null,"tagName":"h3"},{"title":"lt​","type":1,"pageTitle":"Val","url":"/Val/api/Val#lt","content":"&lt;/&gt; Val:lt(other: Val) → boolean Checks if the state's value is less than the value of other Equivalent to state:get() &lt; other:get() local a = Val.new(20) local b = Val.new(30) local c = Val.new(10) local d = Val.new(20) print(a:lt(b)) -- true print(a:lt(c)) -- false print(a:lt(d)) -- false   ","version":null,"tagName":"h3"},{"title":"le​","type":1,"pageTitle":"Val","url":"/Val/api/Val#le","content":"&lt;/&gt; Val:le(other: Val) → boolean Checks if the state's value is less than or equal to the value of other Equivalent to state:get() &lt; other:get() local a = Val.new(20) local b = Val.new(30) local c = Val.new(10) local d = Val.new(20) print(a:le(b)) -- true print(a:le(c)) -- false print(a:le(d)) -- true   ","version":null,"tagName":"h3"},{"title":"gt​","type":1,"pageTitle":"Val","url":"/Val/api/Val#gt","content":"&lt;/&gt; Val:gt(other: Val) → boolean Checks if the state's value is greater than the value of other Equivalent to state:get() &gt; other:get() local a = Val.new(20) local b = Val.new(30) local c = Val.new(10) local d = Val.new(20) print(a:gt(b)) -- false print(a:gt(c)) -- true print(a:gt(d)) -- false   ","version":null,"tagName":"h3"},{"title":"ge​","type":1,"pageTitle":"Val","url":"/Val/api/Val#ge","content":"&lt;/&gt; Val:ge(other: Val) → boolean Checks if the state's value is greater than or equal to the value of other Equivalent to state:get() &gt; other:get() local a = Val.new(20) local b = Val.new(30) local c = Val.new(10) local d = Val.new(20) print(a:ge(b)) -- false print(a:ge(c)) -- true print(a:ge(d)) -- true   ","version":null,"tagName":"h3"},{"title":"on​","type":1,"pageTitle":"Val","url":"/Val/api/Val#on","content":"&lt;/&gt; Val:on( callback: ( newValue: T, oldValue?: T, wasCalledImmediately?: boolean ) → (), callImmediately: boolean? ) → disconnect: () → ()-- calling this function will unsubscribe the callback from the state Subscribes a callback to be called every time the state's value changes local num = Val.new(10) local disconnect = num:on(function(newValue) print(&quot;num set to:&quot;, newValue) end) num:set(0) -- num set to: 0 num:set(20) -- num set to: 20 disconnect() num:set(10) -- no output local num = Val.new(10) local disconnect = num:on(function(newValue, oldValue, wasCalledImmediately) print(&quot;was&quot;, oldValue, &quot;- now&quot;, newValue, &quot;-&quot;, wasCalledImmediately) end, true) -- was 10 - now 10 - true num:set(0) -- was 10 now 0 false   ","version":null,"tagName":"h3"},{"title":"die​","type":1,"pageTitle":"Val","url":"/Val/api/Val#die","content":"&lt;/&gt; Val:die( shallow: boolean?-- if true, any states stored inside the current state will be dereferenced rather than destroyed along with the current state ) → () Destroys the state local num = Val.new(10) num:set(20) num:die() num:set(0) -- error local bool = Val.new(true) bool = bool:die() :: any -- sets bool to nil to ensure that it will be garbage collected local foo = Val.new(&quot;foo&quot;) foo.bar = Val.new(&quot;bar&quot;) foo:die() -- also destroys foo.bar local yep = Val.new(true) local nope = Val.new(false) yep.sike = nope yep:die(true) -- nope is still alive   ","version":null,"tagName":"h3"},{"title":"isdead​","type":1,"pageTitle":"Val","url":"/Val/api/Val#isdead","content":"&lt;/&gt; Val:isdead() → boolean-- whether or not the state is dead Note: Val.isdead(state) behaves differently from state:isdead() to provide the same output, only if the state is dead Val.isdead(state) checks the metatable of the state while state:isdead() calls a metamethod to return true local x = Val.new(true) print(x:isdead()) -- false print(Val.isdead(x)) -- false x:die() print(x:isdead()) -- true print(Val.isdead(x)) -- true print(x:get()) -- error   ","version":null,"tagName":"h3"},{"title":"copy​","type":1,"pageTitle":"Val","url":"/Val/api/Val#copy","content":"&lt;/&gt; Val:copy() → Val Creates a copy of the state The cloned state will not be connected to any callbacks. This also means that a cloned states will not be connected to any computeds. This method only creates a shallow copy, so states embedded inside the clone will be the same states as the original in memory. Computeds will use the same states as the original local a = Val.new(0) a:on(function(value) print(&quot;set to&quot;, value) end) local b = a:copy() print(a == b) -- false print(a:eq(b)) -- true a:set(1) -- set to 1 b:set(2) -- no output print(a:get(), b:get()) -- 1, 2  ","version":null,"tagName":"h3"}],"options":{"id":"default"}}